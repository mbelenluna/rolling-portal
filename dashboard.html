<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Crowdsourcing Portal — New Request | Rolling Translations</title>
  <meta name="robots" content="noindex, nofollow" />
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdn.jsdelivr.net/npm/emailjs-com@3/dist/email.min.js"></script>
  <link rel="icon" href="data:,">

  <!-- Spinner minimal -->
  <style>
    #quoteStatus {
      display: none;
      align-items: center;
      gap: .5rem;
    }

    #quoteStatus::before {
      content: "";
      width: 0.9em;
      height: 0.9em;
      border: 2px solid currentColor;
      border-top-color: transparent;
      border-radius: 50%;
      display: inline-block;
      animation: spin .8s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>

  <div class="ribbon">
    Crowdsourced Translation — separate, opt-in service for <b>non-regulated, low-risk content</b>.
    <a href="/professional" class="link">Need medical/legal? Professional Services →</a>
  </div>

  <div class="container">
    <img src="images/logo.png" alt="Rolling Translations Logo" class="logo" />
    <h1 class="title">Submit a Crowdsourced Translation</h1>
    <p class="subtitle">
      Upload your file, get an instant quote, and pay securely. <b>Not for medical, legal, or regulated content.</b>
    </p>

    <form id="projectRequestForm" class="card">
      <div class="grid">
        <div>
          <label for="sourceLang">Source Language (*)</label>
          <select id="sourceLang" required>
            <option value="">-- Select --</option>
            <option value="en">English</option>
            <option value="es">Spanish</option>
            <option value="pt">Portuguese</option>
            <option value="fr">French</option>
            <option value="de">German</option>
            <option value="it">Italian</option>
            <option value="ja">Japanese</option>
            <option value="ko">Korean</option>
            <option value="zh">Chinese</option>
          </select>
        </div>
        <div>
          <label for="targetLang">Target Language (*)</label>
          <select id="targetLang" required>
            <option value="">-- Select --</option>
            <option value="en">English</option>
            <option value="es">Spanish</option>
            <option value="pt">Portuguese</option>
            <option value="fr">French</option>
            <option value="de">German</option>
            <option value="it">Italian</option>
            <option value="ja">Japanese</option>
            <option value="ko">Korean</option>
            <option value="zh">Chinese</option>
          </select>
        </div>
      </div>

      <!-- multiple -->
      <label for="files">Upload File(s) (*)</label>
      <input type="file" id="files" multiple required />

      <label for="notes">Notes</label>
      <textarea id="notes" rows="3" placeholder="Context, audience, tone, glossary links..."></textarea>

      <label class="checkbox">
        <input type="checkbox" id="nonRegulated" required />
        I confirm this content is not medical, legal, or otherwise regulated.
      </label>

      <div class="quote card soft">
        <h3>Instant Quote (beta)</h3>

        <!-- status de carga -->
        <div id="quoteStatus" class="muted" role="status" aria-live="polite" style="display:none;">Loading…</div>

        <p class="muted">We’ll auto-count when possible. Otherwise, enter your estimated words.</p>

        <div class="grid">
          <div>
            <label for="estWords">Estimated words (total)</label>
            <input type="number" id="estWords" min="1" step="1" placeholder="e.g., 12000" />
          </div>
          <div>
            <label for="tier">Applied rate</label>
            <input type="text" id="tier" disabled placeholder="$—/word" />
          </div>
          <div>
            <label for="total">Estimated total</label>
            <input type="text" id="total" disabled placeholder="$0.00" />
          </div>
        </div>
        <button type="button" id="calcBtn" class="btn">Calculate</button>
      </div>

      <div class="actions">
        <button type="submit" class="btn primary">Submit & Pay</button>
        <button type="button" id="logoutBtn" class="btn">Log out</button>
      </div>
      <p id="confirmationMsg" class="success" style="display:none;">✅ Request submitted! Redirecting to payment…</p>
    </form>
  </div>

  <iframe name="hiddenFrame" style="display:none;"></iframe>
  <form id="spreadsheetForm" method="POST" target="hiddenFrame" style="display:none;"
    action="https://script.google.com/macros/s/AKfycbxbU9QqHS1oyYMBZz4kdNr1YYNHAlUZLIw-NWum8pjcZ8xckfHQgm6P1Qm6pa3oEzdCKQ/exec">
    <input name="fullname" id="fullnameField" />
    <input name="email" id="emailField" />
    <input name="phonenumber" id="phoneField" />
    <input name="sourceLang" id="sourceLangField" />
    <input name="targetLang" id="targetLangField" />
    <input name="notes" id="notesField" />
    <input name="fileName" id="fileNameField" />
  </form>

  <script type="module">
    // ===== Firebase CDN imports =====
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.7.1/firebase-app.js";
    import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.7.1/firebase-auth.js";
    import { getFirestore, addDoc, collection, serverTimestamp, doc, getDoc } from "https://www.gstatic.com/firebasejs/11.7.1/firebase-firestore.js";
    import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/11.7.1/firebase-storage.js";

    // ===== Firebase config =====
    const firebaseConfig = {
      apiKey: "AIzaSyCRrDn3p9alXlLjZN7SoBkJSodcSk2uZs8",
      authDomain: "rolling-crowdsourcing.firebaseapp.com",
      projectId: "rolling-crowdsourcing",
      storageBucket: "rolling-crowdsourcing.firebasestorage.app",
      messagingSenderId: "831997390366",
      appId: "1:831997390366:web:a86f5223fa22cc250b480f",
      measurementId: "G-77E7560XRX"
    };

    // ===== Init Firebase =====
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const storage = getStorage(app);

    // EmailJS
    emailjs.init("NXdzFSlIax5PRevuB");

    // ===== Auth guard =====
    let clientFullName = "";
    let clientOrg = "";
    let clientEmail = "";

    onAuthStateChanged(auth, async (user) => {
      if (!user) { window.location.href = "index.html"; return; }
      clientEmail = user.email || "";

      const userRef = doc(db, "users", user.uid);
      const snap = await getDoc(userRef);
      if (snap.exists()) {
        const u = snap.data();
        clientFullName = u.fullName || "";
        clientOrg = u.org || "";
      }
    });

    // ===== Logout =====
    const logoutBtn = document.getElementById("logoutBtn");
    if (logoutBtn) {
      logoutBtn.addEventListener("click", () => {
        signOut(auth).then(() => (window.location.href = "index.html"));
      });
    }

    // ===== Instant Quote (beta) =====
    const estWordsEl = document.getElementById("estWords");
    const tierEl = document.getElementById("tier");
    const totalEl = document.getElementById("total");
    const calcBtn = document.getElementById("calcBtn");
    const filesInput = document.getElementById("files");
    const submitBtn = document.querySelector('button[type="submit"]');
    const MIN_TOTAL_USD = 1.00;

    // Para evitar resultados fuera de orden si el usuario cambia rápido
    let quoteRunId = 0;

    function rateForWords(w) {
      if (w >= 1000000) return 0.04;
      if (w >= 500000) return 0.05;
      if (w >= 300000) return 0.055;
      if (w >= 100000) return 0.06;
      if (w >= 50000) return 0.07;
      if (w >= 10000) return 0.08;
      return 0.10;
    }
    function formatUSD(n) {
      return new Intl.NumberFormat("en-US", { style: "currency", currency: "USD" }).format(n);
    }
    function updateUIFromWords(totalWords, rateOverride = null) {
      const w = Number(totalWords || 0);
      const rate = (rateOverride != null) ? Number(rateOverride) : rateForWords(w);
      const raw = w * rate;
      const total = Math.max(raw, MIN_TOTAL_USD);
      const showMin = w > 0 && raw < MIN_TOTAL_USD;
      tierEl.value = `$${rate.toFixed(2)}/word`;
      totalEl.value = formatUSD(total) + (showMin ? " (min)" : "");
      return { rate, total };
    }
    function recalc() {
      const w = parseInt(estWordsEl?.value || "0", 10);
      if (!w || w <= 0) { tierEl.value = ""; totalEl.value = ""; return; }
      updateUIFromWords(w);
    }
    calcBtn?.addEventListener("click", recalc);
    estWordsEl?.addEventListener("input", recalc);

    // ===== Helpers de loading =====
    function setQuoteLoading(isLoading, message = "Loading…") {
      const s = document.getElementById("quoteStatus");
      if (!s) return;
      if (isLoading) {
        s.textContent = message;
        s.style.display = "inline-flex";
        s.setAttribute("aria-busy", "true");
        calcBtn.disabled = true;
        filesInput.disabled = true;
        if (submitBtn) submitBtn.disabled = true;
        tierEl.value = "Loading…";
        totalEl.value = "Loading…";
      } else {
        s.textContent = "";
        s.style.display = "none";
        s.removeAttribute("aria-busy");
        calcBtn.disabled = false;
        filesInput.disabled = false;
        if (submitBtn) submitBtn.disabled = false;
        if (tierEl.value === "Loading…") tierEl.value = "";
        if (totalEl.value === "Loading…") totalEl.value = "";
      }
    }

    // ===== Estado de uploads múltiples =====
    // Estructura: [{ fileName, filePath, downloadURL, words, scanned }]
    let uploadedFiles = [];

    async function uploadAndCountOne(file, user) {
      const safeName = `${Date.now()}_${file.name.replace(/[^\w\-\.]+/g, "_")}`;
      const fileRef = ref(storage, `crowd/uploads/${user.uid}/${safeName}`);
      await uploadBytes(fileRef, file, { contentType: file.type || "application/octet-stream" });

      let downloadURL = null;
      try { downloadURL = await getDownloadURL(fileRef); } catch { downloadURL = null; }

      const gsPath = `crowd/uploads/${user.uid}/${safeName}`;

      // Llamar a la función de conteo
      const quoteResp = await fetch("https://us-central1-rolling-crowdsourcing.cloudfunctions.net/getQuoteForFile", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ gsPath, uid: user.uid })
      });
      if (!quoteResp.ok) throw new Error(`HTTP ${quoteResp.status}`);
      const q = await quoteResp.json();

      if (q.scanned) {
        return { fileName: file.name, filePath: gsPath, downloadURL, words: 0, scanned: true };
      }

      const words = Number(q.words || 0);
      return { fileName: file.name, filePath: gsPath, downloadURL, words, scanned: false };
    }

    // Subir + cotizar automáticamente al elegir archivos
    filesInput.addEventListener("change", async (e) => {
      const files = Array.from(e.target.files || []);
      if (!files.length) return;

      const myRun = ++quoteRunId;
      setQuoteLoading(true, "Uploading & counting…");

      try {
        const user = auth.currentUser;
        if (!user) { setQuoteLoading(false); alert("Session expired. Please sign in again."); return; }

        const results = await Promise.all(files.map(f => uploadAndCountOne(f, user)));

        if (myRun !== quoteRunId) return; // llegó otra corrida más nueva

        uploadedFiles = results;

        if (results.some(r => r.scanned)) {
          alert("We detected one or more scanned PDFs. Please provide an estimated word count for those or upload text-based files.");
        }

        const totalWords = results.reduce((sum, r) => sum + (Number(r.words) || 0), 0);
        estWordsEl.value = totalWords > 0 ? String(totalWords) : "";
        updateUIFromWords(totalWords);

      } catch (err) {
        console.error(err);
        alert("Could not auto-count some files. You can still enter a total estimate manually.");
        uploadedFiles = [];
      } finally {
        if (myRun === quoteRunId) setQuoteLoading(false);
      }
    });

    // ===== Submit & Pay flow =====
    const form = document.getElementById("projectRequestForm");
    const confirmationMsg = document.getElementById("confirmationMsg");

    form.addEventListener("submit", async (e) => {
      e.preventDefault();

      const nonReg = document.getElementById("nonRegulated");
      if (!nonReg?.checked) {
        alert("Please confirm this is non-regulated content.");
        return;
      }

      const sourceLang = document.getElementById("sourceLang").value;
      const targetLang = document.getElementById("targetLang").value;
      const notes = document.getElementById("notes").value;
      const user = auth.currentUser;
      if (!user) { alert("Session expired. Please sign in again."); return; }

      // Si el usuario pegó archivos pero no subimos aún (reingreso), subimos ahora:
      if (!uploadedFiles.length) {
        const files = Array.from(filesInput.files || []);
        if (!files.length) { alert("Please select at least one file."); return; }
        setQuoteLoading(true, "Uploading & counting…");
        const myRun = ++quoteRunId;
        try {
          const results = await Promise.all(files.map(f => uploadAndCountOne(f, user)));
          if (myRun !== quoteRunId) return;
          uploadedFiles = results;
          if (results.some(r => r.scanned)) {
            alert("We detected one or more scanned PDFs. Please provide an estimated word count for those or upload text-based files.");
          }
        } catch (err) {
          console.warn("Upload/count on submit failed:", err?.message || err);
          alert("We couldn't process the files. Please try again.");
          setQuoteLoading(false);
          return;
        } finally {
          if (myRun === quoteRunId) setQuoteLoading(false);
        }
      }

      const countedWords = uploadedFiles.reduce((sum, r) => sum + (Number(r.words) || 0), 0);
      const estWordsManual = parseInt(estWordsEl?.value || "0", 10) || 0;
      const totalWords = estWordsManual > 0 ? estWordsManual : countedWords;

      const { rate: rateFinal, total: totalFinal } = updateUIFromWords(totalWords);

      try {
        const payload = {
          email: clientEmail,
          fullName: clientFullName,
          org: clientOrg,
          sourceLang,
          targetLang,
          notes,
          files: uploadedFiles.map(f => ({
            fileName: f.fileName,
            filePath: f.filePath,
            downloadURL: f.downloadURL || null,
            words: Number(f.words || 0),
            scanned: !!f.scanned
          })),
          totalWords: totalWords,
          rate: rateFinal,
          estimatedTotal: rateFinal ? totalFinal : MIN_TOTAL_USD,
          nonRegulated: true,
          status: "pending_payment",
          createdAt: serverTimestamp(),
          ownerUid: user.uid
        };

        const listNames = uploadedFiles.map(f => f.fileName).join(", ");
        document.getElementById("fullnameField").value = clientFullName;
        document.getElementById("emailField").value = clientEmail || "info@rolling-translations.com";
        document.getElementById("phoneField").value = "";
        document.getElementById("sourceLangField").value = sourceLang;
        document.getElementById("targetLangField").value = targetLang;
        document.getElementById("notesField").value = notes;
        document.getElementById("fileNameField").value = listNames;

        console.log("payload to Firestore", payload);

        const reqRef = await addDoc(collection(db, "crowdRequests"), payload);

        try {
          await emailjs.send("service_mugdac3", "template_a6ade8h", {
            sourceLang, targetLang, notes,
            file: listNames,
            email: clientEmail || "info@rolling-translations.com",
            clientFullName, clientOrg, requestId: reqRef.id
          });
        } catch (e) { console.warn("EmailJS:", e?.message || e); }

        try { document.getElementById("spreadsheetForm").submit(); } catch (e) { console.warn("Apps Script:", e?.message || e); }

        // Muestra el OK antes de ir a pagar
        confirmationMsg.style.display = "block";

        // === Redirect to Stripe Checkout ===
        try {
          // (opcional) muestra loading en el card de cotización, si tenés setQuoteLoading
          if (typeof setQuoteLoading === "function") setQuoteLoading(true, "Opening payment…");

          const resp = await fetch("https://us-central1-rolling-crowdsourcing.cloudfunctions.net/createCheckoutSession", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              requestId: reqRef.id,
              totalWords, // el total final que ya calculaste
              email: clientEmail || null,
              description: `Files: ${uploadedFiles.map(f => f.fileName).join(", ").slice(0, 500)}`
            })
          });
          if (!resp.ok) {
            const body = await resp.text();
            console.error("Checkout bad response:", resp.status, body);
            throw new Error(`Checkout HTTP ${resp.status}`);
          }
          const { url } = await resp.json();

          // Redirige al Checkout de Stripe
          window.location.href = url;
          return; // importante: no sigas con reset()
        } catch (e) {
          console.error("Checkout redirect error:", e);
          if (typeof setQuoteLoading === "function") setQuoteLoading(false);
          alert("We couldn't start the payment. Please try again.");
        }


      } catch (error) {
        console.error(error);
        alert("⚠️ Error: " + (error?.message || error));
      }
    });
  </script>
</body>

</html>